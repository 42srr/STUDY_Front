[모던 자바스크립트 Deep Dive]
[25장] 클래스

---

### 1. 클래스는 프로토타입의 문법적 설탕인가?

- 클래스는 프로토타입의 문법적 설탕인가?

	- 프로토타입 기반 객체지향 언어(ES5 등)는 클래스 없이도 생성자 함수, 프로토타입을 통해 상속을 구현함

	- 클래스는 함수이며, 기존 프로토타입 기반 패턴을 클래스 기반 패턴처럼 사용할 수 있도록 함

- 클래스의 생성자 함수와의 차이

	- 클래스
	
		- new 연산자 없으면 오류
		
		- 상속을 지원하는 extends, super 키워드가 있음
		
		- 호이스팅이 발생하지 않는 것처럼 동작함
	
		- 내부 모든 코드에는 암묵적으로 strict mode가 지정 실행되며 해제 불가능함
		
		- constructor, 프로토타입 메서드, 정적 메서드는 모두 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false임 (열거 X)
	
	- 생성자
	
		- new 연산자 없으면 일반 함수로 호출
		
		- 상속을 지원하는 키워드가 없음
		
		- 함수 선언문으로 정의된 생성자는 함수 호이스팅이, 함수 표현식으로 정의된 생성자는 변수 호이스팅이 발생함
		
		- 암묵적으로 strict mode가 지정되지 않음

---

### 2. 클래스 정의

- 클래스

	- class 키워드를 사용해 정의 (+ 보통은 파스칼 케이스)
	
		- class Person {}
		
		- const Person = class {}; // 익명
		
		- const Person = class MyClass {}; // 기명

	- 클래스는 값 사용이 가능한 일급 객체, 함수로서 표현식으로 정의 가능함
	
		- 무명의 리터럴로 생성 가능 (런타임 생성 가능)
		
		- 변수, 자료 구조(객체, 배열 등)에 저장 가능
		
		- 함수의 매개변수에 전달 가능
		
		- 함수의 반환값으로 사용 가능

	- 정의 가능한 메서드
	
		- 생성자, 프로토타입 메서드, 정적 메서드

---

### 3. 클래스 호이스팅

- 클래스 선언문 생성 시 함수로 평가

	- console.log(typeof Person); -> function
	
	- 런타임 이전(소스 코드 평가 과정)에 평가되어 함수 객체(생성자 함수 + 프로토타입)를 생성함
	
		- 생성자 함수, 프로토타입은 언제나 쌍으로 존재함
	
- 클래스 선언문의 클래스 호이스팅

	- 클래스 선언문은 호이스팅이 발생하지만, 클래스 선언문 이전에 일시적 사각지대에 빠지기에 발생하지 않는 것처럼 보임
	
	- 클래스는 let, const 변수처럼 호이스팅됨
	
		- 모든 선언문은 런타임 이전에 먼저 실행되기에 var, let, const, function, fuction*, class 키워드로 선언된 모든 식별자는 호이스팅 됨

---

### 4. 인스턴스 생성

- 클래스의 인스턴스 생성

	- 클래스는 생성자 함수로, new 연산자와 함께 호출되어 인스턴스를 생성함 (존재 이유)
	
		- class Person {} class me = Person();
	
	- 클래스 표현식의 경우 식별자를 사용해 인스턴스를 생성해야 함
	
		- const Person = new MyClass {}; const me = new Person();

---

### 5. 메서드

#### constructor

- 클래스의 constructor (함수 객체 코드의 일부)

	- 인스턴스를 생성하고 초기화하기 위한 특수 메서드, 이름 변경 불가능함
	
		- class Person { constructor(name) { this.name = name; } }
		
	- 생성자 함수와 차이점이 존재함
	
		- 클래스 내 최대 한 개만 존재 가능함
		
		- 생략 시 암묵적으로 빈 constructor가 정의되고 빈 객체롤 생성 가능함
		
		- 초기화된 인스턴스 생성 시 constructor 내부에서 this에 인스턴스 프로퍼티를 추가함
		
		- 프로퍼티 추가를 통해 초기값 전달 가능함
		
		- 별도의 반환문이 없으며, this가 아닌 다른 객체를 명시적 반환하면 인스턴스 반환되지 못하고 명시한 객체가 반환됨, 단, 원시값이라면 무시되고 this 반환됨
	
- 프로토타입의 constructor 프로퍼티

	- 모든 프로토타입이 가지고 있는 프로퍼티이며, 생성자 함수를 가리킴 

#### 프로토타입 메서드

- 생성자 함수로 인스턴스 생성 시 프로토타입 메서드 생성

	- 명시적으로 프로토타입에 메서드를 추가해야 함
	
		- function Person(name) { this.name = name; } Person.prototype.sayHi = function { console.log(`${this.name}`); };
		
		
- 클래스 몸체에서 정의한 메서드의 프로토타입 메서드 생성

	- 클래스의 prototype 프로퍼티에 메서드를 추가하지 않아도 기본적으로 프로토타입 메서드가 됨
	
		- class Person { constructor(name) { this.name = name; } sayHi() { console.log(`${this.name}`);
		
- 클래스가 생성한 인스턴스
	
	- 프로토타입 체인의 일원이 됨
	
		- Object.getPrototypeOf(me) === Person.prototype; -> true
		
		- Object.getPrototypeOf(Person.prototype) === Object.prototype; -> true
		
		- me.constructor === Person; -> true

#### 정적 메서드

- 정적 메서드

	- 인스턴스를 생성하지 않아도 호출 가능한 메서드
	
	- 생성자 함수의 경우 정적 메서드 생성 위해 명시적으로 생성자 함수에 메서드 추가
	
		- Person.sayHi = function () { console.log(...); };
	
	- 클래스에서는 static 정적 메서드(클래스 메서드) 추가
	
		- class Person { ... statuc sayHi() { console.log(...); } }
		
	- 정적 메서드는 클래스 정의 이후 인스턴스 생성하지 않아도 클래스로 호출 가능함
	
		- 클래스는 클래스 정의 평가 시점에 함수 객체가 되므로 별 다른 생성 과정이 필요 없음
		
	- 정적 메서드는 인스턴스 호출 불가능함
	
		- 정적 메서드가 바인딩된 클래스는 인스턴스의 프로토타입 체인상 존재하지 않아서 인스턴스로 클래스의 메서드를 상속받을 수 없음

#### 정적 메서드와 프로토타입 메서드의 차이

- 정적 메서드와 프로토타입 메서드의 차이

	- 정적 메서드와 프로토타입 메서드는 자신이 속해 있는 프로토타입 체인이 다름
	
	- 정적 메서드는 클래스로 호출, 프로토타입 메서드는 인스턴스로 호출
	
	- 정적 메서드는 인스턴스 프로퍼티를 참조 불가능, 프로토타입 메서드는 인스턴스 프로퍼티를 참조 가능	

#### 클래스에서 정의한 메서드의 특징

- 클래스에서 정의한 메서드의 특징

	- function 키워드를 생략한 메서드 축약 표현을 사용함
	
	- 객체 리터럴 과는 다르게 클래스에 메서드를 정의할 때는 콤마가 필요 없음
	
	- 암묵적으로 strict mode로 실행됨
	
	- for...in 문이나 Object.keys 메서드 등으로 열거 불가능함 (프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false)
	
	- 내부 메서드 [[Construct]]를 갖지 않는 non-constructor이므로 new 연산자와 함께 호출 불가능함

---

### 6. 클래스의 인스턴스 생성 과정

- 클래스의 인스턴스 생성 과정

	- 1. 인스턴스 생성과 this 바인딩
	
		- constructor 내부의 클래스가 생성한 인스턴스(빈 객체)의 프로토타입으로 클래스의 prototype 프로퍼티가 가리키는 객체가 설정됨, 인스턴스는 this에 바인딩됨
	
	- 2. 인스턴스 초기화
	
		- constructor 내부 코드가 실행돼 this 바인딩된 인스턴스를 초기화함
	
	- 3. 인스턴스 반환
	
		- 완성된 인스턴스가 바인딩된 this를 암묵적으로 반환
		
	- class Person { constructor(name) { (this -> Person {}); (Object.getPrototypeOf(this) === Person.prototype -> true); this.name; }

---

### 7. 프로퍼티

#### 인스턴스 프로퍼티

- 인스턴스 프로퍼티

	- constructor 내부에서 정의해야 함
	
	- this에 추가한 프로퍼티는 클래스가 생성한 인스턴스의 프로퍼티가 됨

#### 접근자 프로퍼티

- 접근자 프로퍼티
	
	- 자체적으로는 값([[Value]] 내부 슬롯)을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수로 구성된 프로퍼티
	
	- getter, setter로 구성됨 (내부적으로 호출)

	- 클래스의 메서드는 기본적으로 프로토타입 메서드가 되므로, 클래스의 접근자 프로퍼티도 인스턴스 프로퍼티가 아닌 프로토타입의 프로퍼티가 됨

#### 클래스 필드 정의 제안

- 클래스 필드

	- 클래스 기반 객체지향 언어에서 클래스가 생성할 인스턴스의 프로퍼티
	
- TC39 프로세스

	- ECMA-262 사양에 새로운 표준 사양을 추가하기위해 공식적으로 명문화해 놓은 과정
	
- 클래스 필드 정의 제안

	- 클래스 몸체에서 클래스 필드를 정의할 수 있음
	
		- class Person { name = 'Lee'; } const me = new Person(); console.log(me); -> Person {name: "Lee"}
		
	- 클래스 몸체에서 클래스 필드 정의 시 this에 클래스 필드 바인딩 해선 안 됨 (this는 클래스 constructor와 메서드 내에서만 유효함)
	
	- 클래스 필드 참조 시 자바스크립트에서는 반드시 this을 사용함
	
	- 클래스 필드에 초기값 할당하지 않으면 undefined를 가짐
	
	- 인스턴스 생성 시 외부 초기값으로 필드 초기화하려면 constructor에서 클래스 필드 초기화해야 함 (이때 this 프로퍼티 자동 추가 가능)
	
	- 함수는 일급 객체이므로 함수를 클래스 필드에 할당 가능함, 메서드(인스턴스 메서드) 정의 가능함

	- 클래스 필드 내 화살표 함수는 메모리 손해 유발함

#### private 필드 정의 제안

- private 필드 정의 제안
	
	- private 필드의 선두에 #을 붙이고, 참조 시에도 붙임
	
	- 내부에서만 참조 가능, 접근자 프로퍼티를 통해 간접적으로 접근 가능
	
	- 반드시 클래스 몸체에서 정의해야 함
	
	- 클래스 필드 정의 제안을 사용해도 클래스 필드는 기본적으로 public이지만, Typescript 에서 접근 제한자 제공

#### static 필드 정의 제안

- static 필드 정의 제안

	- static PI = 22/7; static #num = 10;

---

### 8. 상속에 의한 클래스 확장

#### 클래스 상속과 생성자 함수 상속

- 프로토타입 기반 상속 

	- 프로토타입 체인을 통해 다른 객체의 자산을 상속 받는 것

- 상속에 의한 클래스 확장

	- 기존 클래스를 상속 받아 새로운 클래스를 확장해 정의하는 것
	
	- 클래스는 생성자 함수와 비슷하지만 다르게 상속으로 클래스를 확장하는 문법이 존재함

#### extends 키워드

- extends 키워드

	- 수퍼클래스와 서브클래스 간의 상속 관계를 설정함
	
		- 이들은 인스턴스의 프로토타입 체인, 클래스 간의 프로토타입 체인을 생성하며, 이를 통해 프로토타입 메서드, 정적 메서드 모두 상속함
	
	- class Base {}, class Derived extends Base {}

#### 동적 상속

- 동적 상속

	- 클래스와 extends로 생성자 함수를 상속 받아 클래스 확장할 수도 있음
	
		- function Base(a) { this.a = a; }

	- [[Constructor]] 내부 메서드를 갖는 함수 객체가 될 수 있는 표현식도 사용 가능함
	
		- class Derived extends (condition ? Base1 : Base2) {}
	
#### 서브클래스의 constructor

- 서브클래스의 constructor

	- constructor() {} // 클래스 constructor 생략 시

	- constructor(...args) { super(...args); } // 서브클래스 constructor 생략 시
	
		- super()는 수퍼클래스의 constructor를 호출해 인스턴스를 생성함
		
- Rest 파라미터

	- 매개변수에 ...을 붙이면 Rest 파라미터가 됨
	
	- 함수에 전달된 인수들의 목록을 배열로 전달 받음

#### super 키워드

- super 키워드

	- 함수처럼 호출 가능하며, this와 같이 식별자처럼 참조 가능한 특수 키워드
	
	- super 호출 시 수퍼클래스의 constructor를 호출함
	
		- 서브클래스에서 constructor을 생략하지 않을 시 반드시 super 호출해야 함
		
		- 서브클래스의 constructor에서 super 호출 전 this 참조가 불가능함
		
		- super는 반드시 서브클래스의 constructor에서만 호출함
	
	- super 참조 시 수퍼클래스의 메서드를 호출 가능함이
	
		- 서브클래스의 프로토타입 메서드 내에서 super.sayHi는 수퍼클래스의 프로토타입 메서드 sayHi를 가리킴, 이때 super가 수퍼클래스의 prototype 프로퍼티에 바인딩된 프로토타입을 참조 가능해야 함
		
			- Base.prototype.SayHi를 가리키므로 호출 시 call 메서드로 this 전달하여 후 인스턴스를 가리키도록 하여 사용 가능함
	
			- ES6 메서드 축약 표현으로 정의된 함수만이 [[HomeObject]]를 가지며, 이를 가지는 함수만이 super 참조가 가능함
			
		- 서브클래스의 정적 메서드 내에서 super.sayHi는 수퍼클래스의 정적 메서드 sayHi를 가리킴
	
#### 상속 클래스의 인스턴스 생성 과정

- 상속 클래스의 인스턴스 생성 과정

	- 1. 서브클래스의 super 호출
	
		- 서브클래스는 자신이 직접 인스턴스를 생성하지 않고 수퍼클래스에게 인스턴스 생성을 위임하므로, 서브클래스의 constructor에서 super를 호출해야 함
	
	- 2. 수퍼클래스의 인스턴스 생성과 this 바인딩
		
		- 수퍼클래스의 constructor 내부의 코드 실행 이전에 암묵적으로 빈 객체 생성하며, 그 인스턴스는 this에 바인딩됨
		
		- 인스턴스는 수퍼클래스가 생성했지만 new.target가 가리키는 서브클래스가 생성한 것으로 처리됨되므로, 인스턴스의 프로토타입은 서브클래스의 prototype 프로퍼티가 가리키는 객체임	
	
	- 3. 수퍼클래스의 인스턴스 초기화
	
		- 수퍼클래스의 constructor가 실행돼 this에 바인딩된 인스턴스를 초기화함
	
	- 4. 서브클래스 constructor로의 복귀와 this 바인딩
	
		- super 호출 종료 후 서브클래스 constructor로 돌아오면, super가 반환한 인스턴스가 this에 바인딩됨 (서브클래스는 별도의 인스턴스 생성 X, super 이전에 this 참조 불가능함)
			
	- 5. 서브클래스의 인스턴스 초기화
	
		- super 호출 이후, 서브클래스의 constructor의 인스턴스가 초기화됨
	
	- 6. 인스턴스 반환
	
		- 완성된 인스턴스가 바인딩된 this를 암묵적으로 반환함

#### 표준 빌트인 생성자 함수 확장

- 표준 빌트인 생성자 함수 확장

	- extends + 표준 빌트인 객체 (String, Number, Array 등)
	
---
