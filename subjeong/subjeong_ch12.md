[모던 자바스크립트 Deep Dive]
[12장] 함수

---

### 1. 함수란?

- 함수

	- 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것
	
	- 여러 개 존재할 수 있으므로 특정 함수를 구별하기 위해 식별자인 함수 이름 사용 가능함
	
	- 매개 변수 : 함수 내부로 입력을 전달받는 변수
	
	- 인수 : 입력
	
	- 반환값 : 출력
	
- 자바스크립트의 함수 정의 방법

	- 함수 호출 (선언문)
	
		- function add(x,y) {return x+y;} -> add(2,5)

---

### 2. 함수를 사용하는 이유

- 코드 재사용 가능, 유지보수의 편의성 증가, 코드의 신뢰성 증가, 코드 가독성 증가

---

### 3. 함수 리터럴

- 자바스크립트의 함수

	- 객체 타입의 값으로, 함수 리터럴로 생성 가능

		- 리터럴은 평가되어 값을 생성함
	
	- 함수 객체는 일반 객체와 다르게 함수는 호출 가능하며, 고유한 프로퍼티를 가짐

- 함수 리터럴

	- function 키워드
	
	- 함수 이름 : 함수 몸체 내애서만 참조 가능한 식별자, 생략 가능함(기명 함수 or 무명/익명 함수)
	
	- 매개 변수 목록 : 0개 이상의 매개변수가 {..., ...} 형태로 구성, 지정 인수 순서대로 할당됨
	
	- 함수 몸체로 구성 : 함수 호출 시 실행됨
	
	- ex. var f = function add(x,y) {return x+y;}

---

### 4. 함수 정의

- 함수 정의

	- 함수 호출 이전에 인수를 전달 받을 매개변수, 실행문들, 반환값을 지정하는 것
	
	- 함수 선언문
	
		- function add(x,y) {return x+y;}
	
	- 함수 표현식
	
		- var add = function(x,y) {return x+y;};
	
	- Function 생성자 함수
	
		- var add = new Function('x', 'y', 'return x+y');
	
	- 화살표 함수(ES6)
	
		- var add = (x, y) => x+y;

- 변수는 선언, 함수는 정의?

	- 함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당되기 때문

#### 함수 선언문

- 함수 선언문

	- 표현식이 아닌 문
	
	- 함수 선언문으로 정의한 함수는 이전에 호출 가능함

	- 함수 리터럴과 형태가 동일하나, 차이점이 존재함
		
		- 함수 리터럴
		
			- 호출 불가능 (함수를 가리키는 식별자가 없음)
		
			- 함수 이름 생략 가능 -> function(x,y) {return x+y;};
		
		- 함수 선언문
		
			- 호출 가능 (함수를 가리키는 식별자가 있음)
			
			- 함수 이름 생략 불가능 -> function add(x,y) {return x+y;};
			
	- 표현식이 아닌 (선언)문
	
		- 실행 후 완료 값으로 undefined가 출력됨
		
		- 변수 할당이 불가능
		
		- 자바스크립트 엔진이 함수 리터럴과 혼동해 함수 선언문이 변수에 할당되는 것처럼 보임
		
			- ex. var add = function add(x,y) {return x+y;}; -> add(2,5)
			
		- 함수 리터럴을 단독 사용 시 함수 선언문으로 해석
		
			- ex. function foo() {console.log('foo');} foo() -> foo
			
			- foo는 함수 몸체 내부에서만 유효한 식별자(함수 이름)이므로 호출 불가능하지만, 별도로 생성된 함수 객체를 가리키는 식별자가 필요
		
				- 자바스크립트 엔진이 생성된 함수 호출을 위해 함수 이름과 동일한 이름의 식별자를 암묵적 생성, 함수 객체를 할당함
		
		- 함수 리터럴을 피연산자로 사용 시 함수 리터럴으로 해석, *()는 그룹 연산자
		
			- ex. (function bar() {console.log('bar');}); bar() -> ReferenceError

#### 함수 표현식

- 일급 객체란?

	- 값의 성질을 갖는 객체, 값처럼 자유롭게 사용 가능함
	
- 함수 표현식

	- 함수는 일급 객체이므로, 함수 리터럴로 생성한 함수 객체를 변수에 할당
	
	- 표현식인 문, 변수에 할당되는 값이 함수 리터럴인 문
	
	- 함수 표현식으로 정의한 함수는 이전에 호출 불가능함
	
	- 기명 함수 : 함수 이름을 생략하지 않은 함수 리터럴
	
	- 익명 함수 : 함수 이름을 생략한 함수 리터럴

#### 함수 생성 시점과 함수 호이스팅

- 함수 선언문(이전 호출 가능)과 함수 표현식(이전 호출 불가능)의 호출 가능 위치가 다른 이유는?

	- 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르기 때문
	
- 함수 호이스팅

	- 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징
	
	- 런타임(코드 순차 실행) 이전에 자바스크립트 엔진에 의해 모든 선언문이 먼저 실행되고, 이때 함수 객체가 먼저 생성됨
	
		- 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당함

	- 변수 호이스팅과 비슷하지만 차이점이 존재함
	
		- 변수 호이스팅 : var 키워드로 선언되어 undefined로 초기화됨
		
		- 함수 호이스팅 : 함수 선언문을 통해 암묵적 생성되어 함수 객체로 초기화됨
		
- 함수 표현식으로 함수를 정의하면, 함수 호이스팅이 아닌 변수 호이스팅이 발생함

	- 변수 할당문은 런타임에 평가되고, 함수 표현식의 함수 리터럴도 런타임에 평가됨
	
	- 이전 호출 시 undefined 호출과 마찬가지이므로 TypeError 발생	

#### Function 생성자 함수

- Function 생성자 함수(빌트인 함수)를 (+ new 연산자) 호출하면 함수 객체를 생성하여 반환

- 생성자 함수

	- 객체를 생성하는 함수
	
- Function 생성자 함수

	- 클로저를 생성하지 않는 등 다르게 동작함
	
	- ex. var add = new Function('x', 'y', 'return x+y');

#### 화살표 함수

- 화살표 함수

	- function 키워드 대신 화살표 => 를 사용해 좀 더 간략한 방법으로 함수를 선언 가능함
	
	- 표현, 내부 동작이 간략화되어 있음
		
		- this 바인딩 방식이 다름, 생성자 함수로 사용 X, prototype 프로퍼티 X, arguments 객체 생성 X
	
	- 항상 익명 함수로 정의함
	
		- ex. const add = (x,y) => x+y; add(2, 5); -> 7

---

### 5. 함수 호출

#### 매개변수와 인수

- 매개변수

	- 함수를 정의할 때 선언하며, 함수 몸체 내부에서 변수와 동일 취급함
	
		- 함수 몸체 외부에서는 참조 불가능 (== 스코프는 함수 내부)
	
	- 함수 호출 시 함수 몸체 내에서 암묵적으로 매개변수가 생성되고 undefined로 초기화된 이후 인수가 순서대로 할당됨
	
		- 매개변수를 통해 인수가 전달됨

- 인수

	- 값으로 평가될 수 있는 식이어야 함
	
	- 함수 호출 시 지정하며, 개수와 타입에 제한이 없음
	
- 함수는 매개변수의 개수와 인수의 개수가 일치하는지 체크하지 않음
	
	- 인수가 부족해서 인수가 할당되지 않은 매개변수의 값은 undefined임
	
	- 인수가 초과돼도 모든 인수는 암묵적으로 arguments 객체의 프로퍼티로 보관되고 있음
	
- arguments 객체

	- 함수 정의 시 매개변수 개수를 확정할 수 없는 가변 인자 함수 구현 시 사용

#### 인수 확인

- 1. 자바스크립트 타입은 매개변수와 인수의 개수가 일치하는지 확인하지 않음

- 2. 자바스크립트는 동적 타입 언어로, 자바스크립트 함수는 매개변수의 타입을 사전에 지정할 수 없음

- 해결법

	- 함수 정의 시 적절한 인수가 전달되었는지 확인하는 방법, 에러는 런타임 시 발생

		- ex. if (typeof x !== 'number' || typeof y !== 'number') {throw new TypeError('인수는 모두 숫자 값이어야 함');}

	- 타입스크립트 등을 통해 컴파일 시점에 부적절한 호출 방지하는 방법
	
	- arguments 객체를 통해 인수 개수 확인하는 방법
	
	- 인수가 전달되지 않은 경우 단축 평가를 사용해 매개변수에 기본값 할당하는 방법 (인수 미전달, undefined 전달의 경우)
	
		- ex. function add(a) {a=a||0; return a;}

#### 매개변수의 최대 개수

- 매개변수의 최대 개수를 제한하고 있지 않지만, 물리적 한계가 있음

- 이상적인 함수는 한 가지 일만 해야 하며 가급적 작게 만들어야 함

- 객체를 인수로 사용하는 경우 프로퍼티 키만 정확히 지정하면 매개변수의 순서를 신경 쓰지 않아도 됨

	- ex. data: {id: 1, name: 'Lee'}
	
- 함수 외부에서 함수 내부로 전달한 객체를 함수 내부에서 변경하면, 함수 외부의 객체가 변경되는 부수 효과가 있음

#### 반환문

- 함수는 반환문을 사용해 실행 결과를 함수 외부로 반환 가능함

- 반환문

	- return 키워드 + 표현식(반환값)
	
	- 함수 호출은 표현식이므로, 함수 호출 표현식은 return 키워드가 반환값이 평가됨
	
	- 반환문은 생략 가능함, 이때 함수는 함수 몸체의 마지막 문까지 실행한 후 암묵적으로 undefined를 반환함

		- function foo() {} console.log(foo()) -> undefined

	- return 키워드와 반환값 표현식 사이에 줄바꿈이 있으면 세미콜론이 자동 삽입됨
	
	- 반환문은 함수 몸체 내부에서만 사용 가능함
	
- 반환문의 역할

	- 반환문은 함수의 실행을 중단하고 함수 몸체를 빠져 나가므로, 이후 다른 문이 존재하면 무시함
	
		- function foo() {return('o'); console.log('x');} console.log(foo()); -> 'o' 	
	
	- 반환문은 return 키워드 뒤에 오는 표현식을 평가해 반환하므로, 표현식을 명시적으로 지정하지 않으면 undefined가 반환됨
	
		- function foo() {return;} console.log(foo()); -> undefined

---

### 6. 참조에 의한 전달과 외부 상태의 변경

- 원시 값은 값에 의한 전달, 객체는 참조에 의한 전달 방식으로 동작함

	- 매개변수도 함수 호출 시 매개변수에 값을 전달하는 방식을 값에 의한 호출, 참조에 의한 호출로 함

	- 함수의 외부에서 함수 몸체 내부로 전달한 원시 값의 원본은 변경되지 않음

	- 함수 몸체에서 참조 값을 통해 객체를 변경할 경우 원본이 훼손됨 (객체 타입은 참조 값이 복사되어 매개변수에 전달)

- 객체 변경을 추적하기 위해 불변 객체로 바꿀 수 있음 (+ 옵저버 패턴)

	- 객체 상태 변경 시 깊은 복사로 새로운 객체를 생성하고 재할당을 통해 교체하여 외부 상태 변경되는 부수 효과를 없앨 수 있음

- 순수 함수

	- 외부 상태를 변경하지 않고 외부 상태에 의존하지 않는 함수	
	
	- 순수 함수를 통해 부수 효과를 최대 억제, 안정성 증대하는 프로그래밍 패러다임을 함수형 프로그래밍이라 함
	
---

### 7. 다양한 함수의 형태

#### 즉시 실행 함수

- 즉시 실행 함수

	- 함수 정의와 동시에 즉시 호출되는 함수, 익명 함수(일반적)
	
	- 단 한 번만 호출되어 재호출 불가능함
	
	- 함수 리터럴을 평가해서 함수 객체를 생성하기 위해 그룹 연산자로 함수를 묶음

		- (function () { return 1 * 2; }());
	
	- 일반 함수처럼 값 반환, 인수 전달 가능함
	
		- (function () {...}());
	
		- (function () {...})();
	
		- !function () {...}();
	
		- +function () {...}();
	
- 에러 사항

	- (function foo() {return 1 * 2; }());
	
		- 그룹 연산자 내 기명 함수는 함수 선언문이 아닌 함수 리터럴로 평가되어 재호출 불가능함
	
	- function () {...}();

		- 함수 언언문은 함수 이름을 생략할 수 없음
		
	- function foo() {...}();
	
		- 선언문 뒤 실행 함수는 그룹 연산자 (...)로 감싸야 함
		
	- function foo() {}();
	
		- 자바스크립트 엔진이 암묵적으로 선언문 뒤에 세미콜론을 추가함함수 선언문은 함수 이름을 생략할 수 없음
		
	- ();
	
		- 함수 선언문 뒤의 (...)는 함수 호출 연산자가 아닌 피연산자 없는 그룹 연산자로 인식됨
	
	- function f(){} -> function / function (){} -> function
	
		- 그룹 연산자의 피연산자는 값으로 평가되므로, 기명 함수를 그룹 연산자로 감싸면 함수 리터럴로 평가되어 함수 객체가 됨

#### 재귀 함수

- 재귀 함수

	- 반복되는 처리를 위해 사용함
	
	- 탈출 조건을 반드시 만들어야 하며, 그렇지 않으면 스택 오버플로 에러 발생함
	
	- for문, while 문으로 구현

#### 중첩 함수

- 중첩 함수 (내부 함수)

	- 함수 내부에 정의된 함수
	
	- 중첩 함수는 외부 함수 내부에서만 호출 가능함 (자신을 포함하는 외부 함수를 돕는 헬퍼 함수 역할)
	
		- function outer() { var x = 1; function inner() { console.log(x); } -> 1 inner(); } outer();
	
	- 호이스팅 문제가 발생할 수 있음 (+ 스코프, 클로저)
	
- 외부 함수

	- 중첩 함수를 포함하는 함수

#### 콜백 함수

- 콜백 함수

	- 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수 (자유롭게 교체할 수 있음)

		- function repeat(n, f) { for (var i=0; i<n; i++) f(i); }
	
	- 콜백 함수는 고차 함수에 의해 호출, 이때 고차 함수는 필요에 따라 콜백 함수에 인수 전달 가능함
	
	- 콜백 함수를 전달받는 함수가 자주 호출된다면, 함수 외부에 정의 후 사용하는 것이 효율적임
	
- 고차 함수
	
	- 매개 변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수
	
	- 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출함
		
#### 순수 함수와 비순수 함수

- 순수 함수

	- 함수 내부로 전달된 인수에게만 의존해 값을 생성해 반환함
	
	- 일반적으로 최소 1개 이상의 인수를 전달 받음, 외부 상태를 변경하지 않음
	
- 비순수 함수

	- 외부 상태(전역 변수, 서버 데이터, 파일, Console, DOM)에 의존하거나 외부 상태를 변경하는 함수
	
	- 내부 상태에 의존하더라도 내부 상태가 호출될 때마다 변화하는 값도 비순수 함수임
	
	- 코드의 복잡성을 증가시킴

---
