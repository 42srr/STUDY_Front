# 11장 원시 값과 객체의 비교

- 원시타입 : 변경 불가능한 값. 변수에 실제 값이 저장됨
- 객체타입 : 참조 타입의 값 = 변경 가능한 값. 변수에 참조 값이 저장됨

## 11.1 원시 값

### 11.1.1 변경 불가능한 값

- 원시 타입의 값은 변경 불가능한 값임
- 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름
- 값은 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과
- 원시 값은 값이기 때문에 원시 값이 할당된 변수는 변경할 수 있음
- 즉, 원시 값을 할당한 변수에 새로운 원시 값을 할당할 경우
  - 새로운 메모리 공간을 확보함
  - 재할당 하려는 원시 값을 새로운 메모리 공간에 저장함
  - 변수는 새로운 메모리 공간을 가리킴
  - 원시 값이 변경되는게 아니라 새로운 메모리 주소에 원시 값을 저장하는것
- 이것이 값의 불변성
- 원시 값을 할당한 변수는 재할당을 통해서만 변수 값을 변경할 수 있음

#### 이터러블 = 루프나 스프레드 연산자 등과 함께 사용할 수 있는 순회 가능한 데이터 구조

```
const 이터러블 = ['사과', '배', '바나나'];
for (const 과일 of 이터러블)
{
    console.log(과일);
}
```

### 11.1.2 문자열과 불변성

- 자바스크립트의 문자열은 원시 타입이며 변경 불가능
- 게다가 유사 배열 객체라서 인덱스로 각 문자에 접근 가능.
- 하지만 원시 타입이라 인덱스에 접근해서 변경을 시도해도 반영되지 않음

### 11.1.3 값에 의한 전달

- 값에 의한 전달 = 변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수에는 할당되는 변수의 원시 값이 복사되어 전달됨
- 하지만 원본 값과 복사된 값은 서로 다른 메모리 공간에 저장된 별개의 값임
- 그러므로 원본 값을 변경해도 복사된 값은 변경되지 않음
- 엄밀히 말하면 변수에는 값이 아니라 메모리 주소가 전달되는 것이라는걸 기억하기

## 11.2 객체

- 객체는 프로퍼티를 동적으로 추가, 삭제할 수 있음

### 11.2.1 변경 가능한 값

- 객체 타입의 값은 변경 가능한 값임
- 객체를 할당한 변수는 참조 값에 접근할 수 있음
- 참조 값은 생성된 객체가 저장된 메모리 공간의 주소를 의미함
- 변수는 참조 값을 통해 객체에 접근할 수 있음
- 객체는 재할당 없이 직접 변경 가능함 = 프로퍼티 동적 수정 가능

#### 얕은 복사

- 객체의 최상위 속성만 새로운 메모리에 복사하는 것
- 중첩 객체는 참조를 공유함

```
  const 원본 = {
    최상위객체1: '상위이름',
    최상위객체2: {
        하위객체: '하위이름'
    }
  }
  const 사본 = 얕은복사(원본);
  사본.최상위객체1 = '바뀐상위이름';
  사본.최상위객체2.하위객체 = '바뀐하위이름';

  console.log(원본.최상위객체1);        // 상위이름
  console.log(원본.최상위객체2.하위객체); // 바귄하위이름
```

#### 깊은 복사

- 객체의 모든 속성을 새로운 메모리에 복사하는 것

```
  const 원본 = {
    최상위객체1: '상위이름',
    최상위객체2: {
        하위객체: '하위이름'
    }
  }
  const 사본 = 깊은복사(원본);
  사본.최상위객체1 = '바뀐상위이름';
  사본.최상위객체2.하위객체 = '바뀐하위이름';

  console.log(원본.최상위객체1);        // 상위이름
  console.log(원본.최상위객체2.하위객체); // 하위이름
```

### 11.2.2 참조에 의한 전달

- 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조값이 복사되어 전달됨
- 원본 값과 사본 값은 저장된 메모리 주소는 다르지만 동일한 객체를 참조함
- 이때, 원본 또는 사본에서 객체를 변경하면 서로 영향을 주고받음
- 자바스크립트에는 값에 의한 전달만 존재함
