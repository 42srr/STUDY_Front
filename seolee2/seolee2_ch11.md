### 원시 타입과 객체 타입의 차이점

- 원시타입 : 변경 불가능한 값 / 객체(참조)타입 : 변경 가능한 값
- 변수(확보된 메모리 공간)에 할당 시 : 원시 값 - 실제 값 저장, 객체 값 - 참조 값 저장
- 다른 변수에 할당 시 : 원시 값 - 원시 값 복사(pass by value), 객체 - 참조 값(pass by reference)

# 11.1 원시 값

---

### 11.1.1 변경 불가능한 값

```jsx
한번 생성된 원시 값을 읽기 전용(read only) 값으로서 값 자체는 변경할 수 없음
// 변수에 재할당은 가능하지만 원시 값 자체는 변경할 수 없음

// <-> 상수는 재할당이 금지된 변수
```

```jsx
불변성(immutability) : 변수 값을 변경하기 위해 원시 값을 재할당하면
새로운 메모리 공간을 확보하고 값을 저장한 후 참조 주소를 변경함
```

### 11.1.2 문자열과 불변성

```jsx
원시 값 저장을 위해서는 확보해야 할 메모리 크기를 결정해야 함

JS는 개발자 편의를 위해 원시 타입인 **문자열 타입**을 제공
=> 문자열이 생성된 이후에는 변경할 수 없음 / 재할당은 가능

let str = 'string';

console.log(str[0]); // s 유사 배열 객체이므로 인덱스로 접근 가능
str[0] = 'S'; // 변경은 불가능(에러는 발생하지 않음)
console.log(str); // string
```

<aside>
💡

값에 의한 전달이라고 하지만 엄밀히 말하면 메모리 주소를 전달

그리고 각각 다른 메모리 주소를 갖는 것

</aside>

# 11.2 객체

---

```jsx
프로퍼티의 개수는 정해지지 않음
동적으로 추가, 삭제 가능
값 제약 없음
=> 확보해야 할 메모리 공간의 크기를 사전에 정할 수 없음
=> 사용하기 편하지만 성능 면에서 클래스 기반 언어보다 비효율적
```

### 11.2.1 변경 가능한 값

```jsx
변경 가능하지만 그때마다 원시 값처럼 복사, 생성한다면 비효율적
+ 여러 식별자가 하나의 객체를 공유
```

```jsx
얕은 복사 / 깊은 복사

얕은 복사 : 한 단계까지만 복사    // 중첩된 부분은 참조 값을 복사
깊은 복사 : 중첩된 객체 모두 복사 // 원시 값처럼 완전한 복사본을 만듬
```

### 11.2.2 참조에 의한 전달

```jsx
저장된 메모리 주소는 다르지만 동일한 참조 값을 가지므로
여러 개의 식별자가 하나의 객체를 공유 => 한쪽에서 변경하면 서로 영향을 받음
```

<aside>
💡

자바스크립트에 **참조에 의한 전달**은 존재하지 않음

</aside>
