24장 클로저
<aside>
💡

클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다

</aside>

# 24.1 렉시컬 스코프

---

```jsx
자바스크립트 엔진은 함수를 어디에 정의했는지에 따라 상위 스코프를 결정한다

상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 환경(위치)에 의해 결정됨
```

# 24.2 함수 객체의 내부 슬롯 [[Environment]]

---

```jsx
함수는 자신의 내부 슬롯 [[Environment]]에 상위 스코프의 참조를 저장
```

# 24.3 클로저와 렉시컬 환경

---

```jsx
외부 함수보다 중첩 함수가 오래 유지되는 경우
중첩 함수는 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있다

일반적으로 중첨 함수가 상위 스코프의 식별자를 참조하고,
중첩 함수가 외부 함수보다 오래 유지되는 경우에 한정하여
이러한 중첩 함수를 클로저라고 부른다

클로저에 의해 참조되는 상위 스코프의 변수는 자유 변수라고 부른다

outer 함수의 생명 주기가 종료하더라도
실행 컨텍스트에서 제거될 뿐 렉시컬 환경까지 소멸하는 것은 아님
- inner 함수의 [[Environment]] 내부 슬롯에 의해 참조되므로 가비지 컬렉션의 대상 x
```

# 24.4 클로저의 활용

---

```jsx
상태를 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용

const increase = (function() {
	let num = 0;
	return function() {
		return ++num;
	};
}());
// 즉시 실행 으로 num 만들어두고 기억해둔 렉시컬 환경의 num 값을 변경
```

```jsx
함수를 호출해 함수를 반환하면
반환된 함수마다 독립된 렉시컬 환경을 가짐

즉시 함수를 사용해서 자유 변수를 공유시켜 둬야 연동 가능
```

# 24.5 캡슐화와 정보 은닉

---

```jsx
캡슐화 : 프로퍼티(상태)와 메서드(동작)를 하나로 묶음
정보 은닉 : 캡슐화를 사용해 객체의 특정 프로퍼티나 메서드를 감춤
					=> 정보 보호, 객체 간 상호 의존성(결합도)를 낮춤
			
			
자바스크립트는 접근 제한자(public, private, protected) 미제공
= 자바스크립트의 객체의 모든 프로퍼티, 메서드는 기본적으로 public

자바스크립트는 정보 은닉을 완전하게 지원하지 않음이라고 책에 되어 있지만

최근 자바스크립트(정확히는 ECMAScript)에서는 
클래스에서 # (해시) 접두사를 사용해서 진짜 private 필드를 만들 수 있게 되었어! 라고 함
```

# 24.6 자주 발생하는 실수

---

```jsx
for 문에서 변수를 var로 선언하면 함수 레벨 스코프라 i 값이 공유되어버림 => let 사용
```
