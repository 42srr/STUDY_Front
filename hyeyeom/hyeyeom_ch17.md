▣ 17장: 생성자 함수에 의한 객체 생성

17.1 Object 생성자 함수
- new 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환
- 빈 객체를 생성한 이후 프로퍼티 또는 메서드를 추가하여 객체를 완성
- 생성자 함수 (constructor)란 new 연산자와 함께 호출
    - 객체(인스턴스)를 생성하는 함수
    - 생성자 함수 에 의해 생성된 객체를 인스턴스(instance)
    - 생성자 함수 이외에도 String, Number, Boolean, Function, Array, Date, RegExp, Promise 등의 빌트인
-  Object 생성자 함수를 사용해 빈 객체를 생성해야 하는 것은 아님
    - 객체를 생성하는 방법 : 객체 리터럴이 더 간편
    - 비추 : Object 생성자 함수를 사용해 객체를 생성하는 방식

17.2 생성자 함수
____17.2.1 객체 리터럴에 의한 객체 생성 방식의 문제점
- 객체 리터럴에 의한 객체 생성 방식 : 직관 & 간편
    - 하나의 객체만 생성
    - 동일한 프로퍼티를 갖는 객체를 여러개 생성 해야하는 경우, 매번 같은 프로 퍼티를 기술해야 하기 때문에 비효율적
- 객체 : 프로퍼티를 통해 객체 고유의 상태
    - 메서드를 통해 상태 데이터인 프로퍼티를 참조하고 조작하는 동작 표현
    - 프로퍼티는 객체마다 프로퍼티 값이 다를 수 있음
    - 메서드는 내용이 동일한 경우가 일반적
        ex) circle1 객체와 circle2 객체 -> getDiameter 메서드는 동일
        - 프로퍼티 구조가 동일하지만 매번 같은 프로퍼티 & 메서드 기술

____17.2.2 생성자 함수에 의한 객체 생성 방식의 장점
- 생성자 함수에 의한 객체 생성 방식
    - 마치 객체(인스턴스)를 생성하기 위한 템플릿(클래스)처럼 생성자 함수 사용
    - 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성
- this : 자기 참조 변수
- 생성자 함수 = 이름 그대로 객체(인스턴스)를 생성하는 함수
    - 일반 함수와 동일한 방법으로 생성자 함수를 정의
    - new 연산자와 함께 호출
    - => 해당 함수는 생성자 함수로 동작
- 만약 new 연산자와 함께 생성자 함수를 호출 X -> 생성자 함수가 아니라 일반 함수로 동작.

____17.2.3 생성자 함수의 인스턴스 생성 과정
1. 인스턴스 생성과 this 바인딩
2. 인스턴스 초기화
3. 인스턴스 반환

____17.2.4 내부 메서드 [[Call]]과 [[Construct]]
- 함수 선언문 or 함수 표현식 -> 정의한 함수
    - 일반 함수로 호출할 수 있는 것은 생성자 함수로 호출 가능
- 생성자 함수로서 호출한다는 것 : new 연산자와 함께 호출
    - 객체 생성하는 것을 의미
- 함수 = 객체
    - 일반 객체와 동일하게 동작
    - 일반 객체가 가지고 있는 내부 슬롯과 내부 메서드를 모두 가지고 있음

____17.2.5 constructor와 non-constructor의 구분
- 자바스크립트 엔진이 어떻게 constructor vs. non-constructor의 구분
    - constructor :  함수 선언문, 함수 표현식, 클래스(클래스도 함수다)
    - non-constructor :  메서드, 화살표 함수
* ECMAScript 사양에서 메서드로 인정하는 범위가 일반적인 의미의 메서드보다 좁다

- 함수를 프로퍼티 값으로 사용하면 일반적으로 메서드로 통칭

____17.2.6 new 연산자
- 일반 함수와 생성자 함수에 특별한 형식적 차이는 X
- new 연산자와 함께 함수를 호출시, 해당 함수는 생성자 함수로 동작
- 다시 말해, 함수 객체의 내부 메서드 [[Call]]이 호출되는 것이 아니라 [[Construct]]가호출
    - 단, new 연산자와함께 호출하는 함수 : constructor 이어야 함

____17.2.7 new.target
- 생성자 함수가 new 연산자 없이 호출되는 것을 방지하기 위해 파스칼 케이스 컨벤션을 사용한다 하더라도...
    - 위험성을 회피하기 위해 ES6에서는 new.target을 지원