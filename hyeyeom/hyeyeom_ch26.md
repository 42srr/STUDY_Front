▣ 26장: ES6 함수의 추가 기능
26.1 함수의 구분
- ES6 이전
1. 일반 함수 호출
2. 생성자 함수 (new 연산자 -> 인스턴스 생성)
3. 객체 바인딩 메서드
=> 사용 목적에 따라 명확히 구분 X
=> 모두 callable & constructor

- ES6 이후
    - 일반 함수는 차이 없음
    - 메서드 & 화살표 함수는 차이 있음
    - 일반 함수 : constructor
    - 메서드 & 화살표 함수 : non-constructor
26.2 메서드
-  ES6 이전, 메서드 명확한 정의 X
    - 객체에 바인딩된 함수를 일컫음
- ES6 이후, 메서드 축약 표현 함수만 의미함
```
//메서드 축약 표현
    const obj = {
        x : 1,
        foo () {return this.x;} 
        // ...
    }
```
    - ES6 사양 정의 메서드 = ES6 메서드
        - 인스턴스 생성 불가한 non-constructor
        - 생성자 함수 불가
        - 인스턴스 생성 불가 -> prototype 프로퍼티 X, 프로토 타입 생성 X
    - 표준 빌트인 객체 제공 프로토타입 메서드 & 정적메서드(static) 모두 non-structor
    - ES6메서드, 자신을 바인딩한 객체를 가리키는 내부슬롯 `[[HomeObject]]` 가짐
        - super 키워드 사용가능
        - ES6메서드 아니면 super 사용불가
=> 본연의 기능 추가(super), 의미적으로 맞지 않는 constructor는 삭제
=> 익명 함수 표현식 사용하지 않도록 하기

26.3 화살표 함수
arrow function, `function` 키워드 X -> `=>` (fat arrow) 사용
- 내부 동작도 기존 함수보다 간략
- this가 전역 객체를 가리키는 문제 해결 대안
____26.3.1 화살표 함수 정의
- 함수 정의
    - 함수 표현식으로 정의
    - 호출 방식 : 기존 함수와 동일
- 매개변수 선언
    - 여러개 : 소괄호 안
    - 한 개 : 소괄호 생략 가능
    - 없을 때 : 소괄호 필수
- 함수 몸체 정의
    - 하나의 문으로 구성시, 함수 몸체 감싸는 중괄호 {} 생략 가능
        - 함수 몸체 내부의 문이 표현식이 아닌 문, 에러 발생
        - => 표현식이 아닌 문은 반환 할 수없기 때문
        - 함수 몸체가 하나의 문으로 구성되더라도 함수 몸체의 문이 표현식이 아닌 문이라면 중괄호 생략 X
    - 값으로 평가 되는 표현식인 문이라면 암묵적 반환
    - 객체 리터럴 반환시, 객체 리터럴 소괄호로 감싸줘야함
        - 소괄호 반환 안하면, 객체 리터럴의 중괄호{}를 함수 몸체를 감싸는 중괄호로 잘못 해석함
    - 함수 몸체가 여러개의 문으로 구성시, 함수 몸체를 감싸는 중괄호 생략 불가
        - 반환값이 있다면 명시적으로 반환 필요
    - 즉시 실행 함수 사용가능
    - 일급객체라 고차함수에 인수로 전달가능
        - 일반적인 함수 표현식보다 표현이 간결하고 가독성 좋음
    - 콜백 함수로서 정의할때 유용
        - 일반함수의 기능 간략화 
        -  this 편리하게 설계
____26.3.2 화살표 함수와 일반 함수의 차이
- 차이
1. 인스턴스 생성 불가인 non-structor -> 화살표 함수
    - prototype 프로퍼티 X
    - 프로토타입도 생성하지 않음
2. 중복된 매개변수 이름 선언 X
    - 차이) 일반함수는 가능!
        - strict mode 에선 에러
3. 함수 자체의 this, arguments, super, new.target 바인딩 갖지 X
    - ???
    - 따라서, 화살표 함수 내부에서 위 4개를 참조시, 스코프체인을 통해 상위 스코프의 4개를 참조 (???)
    - 화살표 함수X2 중첩, 상위 화살표 함수에도 4개의 바인딩이 없으므로 가장 가까운 상위 함수 중 화살표 함수가 아닌 함수의 4개를 참조(???)

____26.3.3 this
화살표 함수와 일반 함수가 구별되는 가장 큰 특징이 바로 this!
- 화살표 함수 : 다른 함수의 인수로 전달되어 콜백 함수로 사용 다수
- "콜백 함수 내부의 this 문제 "
    - 콜백 함수 내부의 this vs. ~ 외부의 this 
    - 다르기때문에 생겨나는 문제를 해결하기 위해
    => 의도적으로 설계
- (22장 this 참고) this 바인딩, 함수의 호출 방식 = 함수가 어떻게 호출 되었는지에 따라 동작
    - 함수 정의시, this에 바인딩할 객체가 정적으로 결정 X
    - 함수를 호출할 때, 함수가 어떻게 호출 되었는지에 따라 this에 바인딩할 객체가 동적으로 결정
    - 주의할 점, 일반함수로서 호출되는 콜백 함수의 경우 !
        - 고차 함수의 인수로 전달되어 고차 함수 내부에서 호출되는 콜백 함수도 중첩함수임!
* 여러번 다시 읽어보고 만들어봐야할 부분..

____26.3.4 super
- super 바인딩 갖지 않음
- => super 참조시, 상위 스코프의 super 참조

____26.3.5 arguments
- arguments 바인딩 갖지 않음
- => arguments 참조시, 상위 스코프의 arguments 참조
- 가변인자 함수 구현시, 반드시 Rest 파라미터 사용해야함

26.4 Rest 파라미터
- 매개변수 이름 앞에 3개의 점 ...을 붙여 정의한 매개변수 의미
- 함수에 전달될 인수들의 목록을 배열로 전달 받음
____26.4.1 기본 문법
```
function foo(...rest)
{
    console.log(rest);
}
foo(1, 2, 3, 4, 5);
```
____26.4.2 Rest 파라미터와 arguments 객체
arguments 객체가 유사 배열 객체 (진짜 배열은 X) 그래서 배열 메서드인 Function.prototype.call, Function.prototype.apply를 이용해 배열로 변경해야하는 번거로움 있었음
-> ES6부턴 rest 파라미터 사용지 가변 인자 함수의 인수 목록 -> 배열 직접 전달 받기 가능
- 특히나 화살표 함수는 arguments 객체 갖지 않기 때문에, 반드시 rest 파라미터 사용해야함

26.5 매개변수 기본값
- 매개변수 개수 != 인수 개수 해도 에러 X
- => js 엔진이 체크 안해서
- 인수가 전달되지 않은 매개변수의 값은 ** undefined **
    - 방어코드 필요
    - ES6 도입된 매개변수 기본값 사용시, 함수 내 수행하던 인수체크 & 초기화 가능
    