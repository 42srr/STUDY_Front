# ▣ 24장: 클로저
- 함수를 일급 객체로 취급하는 함수형 프로그래밍 언어에서 가지고 옴
- -> 고유 개념 아님 => ECMAScript 사양에 등장 X
- *"클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합"*
    - "함수가 선언된 렉시컬 환경"
    ```
    const x = 1;

    function outerFunc(){
        function innerFun(){
            console.log(x); // 10
        }
        innerFunc();
    }
    outerFunc();
    ```
    - outerFunc의 x에 innerFunc 접근 가능
    - IF) 중첩되지 않은 함수들로 이루어져 있다면?
        - 스코프가 다르기 때문에 outerFunc 안에서 innerFunc을 호출하더라도
        innerFunc에서 x 변수 사용 불가
        - Why ? 렉시컬 스코프를 따르는 프로그래밍 언어

        ```
        const x = 1;
        function outerFunc(){
            const x = 10;
            innerFunc();
        }
        function innerFunc(){
            console.log(x); //1
        }
        outerFunc();
        ```

## 24.1 렉시컬 스코프
- = 함수를 어디에 정의했는지에 따라 상위 스코프를 결정
foo(), bar() 함수의 상위 스코프는 전역 !
why? 정의한 위치에 따라 정적으로 결정되는 함수의 상위 스코프
(어디서 호출했는지는 중요하지 않음)

- 스코프 체인 : 외부 렉시컬 환경에 대한 참조 -> 상위 렉시컬 환경과 연결
- -> "함수의 상위 스코프를 결정한다" 
- = 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 저장할 참조값을 결정한다 (말이 어.. 어려워)
- 렉시컬 환경의 "외부 렉시컬 환경에 대한 참조"에 저장할 참조값이..! 바로 상위 레시컬 환경에 대한 참조..
- = ** 상위 스코프**

- 외부 렉시컬 환경에 대한 참조에 저장할 참조값 = 상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 환경(위치)에 의해 결정

*일단 호출 위치보다 선언된 위치가 더 중요하다 로 정리*

## 24.2 함수 객체의 내부 슬롯 [[Environment]]
함수는 자신의 내부 슬록 [[Environment]] 에 자신이 정의된 환경 = *상위 스코프의 참조* 저장
- 함수 객체를 생성하는 시점
    - 상위 함수나 전역 코드가 평가 or 실행되고 있는 시점임!
    - 현재 실행중인 실행 컨텍스트 = 상위 함수의 실행 컨텍스트이기 때문
    
## 24.3 클로저와 렉시컬 환경
## 24.4 클로저의 활용
## 24.5 캡슐화와 정보 은닉
## 24.6 자주 발생하는 실수
