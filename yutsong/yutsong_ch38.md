# 38장 브라우저의 렌더링 과정

- 브라우저는 HTML, CSS, JS로 작성된 텍스트 문서를 파싱(해석)하여 브라우저에 렌더링 함

## 38.1 요청과 응답

- 브라우저의 핵심 기능은 필요한 리소스를 서버에 요청하고, 응답받아 렌더링하는 것
- 브라우저의 주소창에 URL을 입력하면 서버에 요청 진행
- URL은 프로토콜과 도메인, 포트, 경로로 이루어져 있음
- URN은 Query와 Fragment로 이루어짐
- URI = URL + URN
- 서버는 루트 경로에 대한 요청에 대해 암묵적으로 index.html을 응답하도록 설정되어있음

## 38.2 HTTP 1.1과 HTTP 2.0

- HTTP는 웹에서 브라우저와 서버가 통신하기 위한 프로토콜
- HTTP/1.1은 커넥션 당 하나의 요청과 응답만 처리할 수 있음
- HTTP/2는 커넥션당 여러 개의 요청과 응답이 가능 함

## 38.3 HTML 파싱과 DOM 생성

- HTML 문서는 문자열로 이루어진 순수한 텍스트
- HTML 문서를 렌더링 하려면 브라우저가 이해할 수 있는 객체로 파싱, 변환해서 메모리에 저장해야 함
- 이 객체를 DOM(Document Object Model)이라고 부름

## 38.4 CSS 파싱과 CSSOM 생성

- HTML 문서를 한 줄씩 순차적으로 파싱해서 DOM을 생성함
- CSS파일도 파싱, 해석하여 CSSOM(CSS Object Model)을 생성하게 됨

## 38.5 렌더 트리 생성

- DOM과 CSSOM은 렌더링을 위한 트리 구조의 자료구조인 렌더 트리로 결합됨
- 렌더 트리에는 화면에 렌더링 되는 노드들로만 구성됨

## 38.6 자바스크립트 파싱과 실행

- DOM은 프로그래밍 인터페이스로서 DOM API도 제공함
- 자바스크립트 코드에서 DOM API를 사용하면 DOM 조작이 가능
- 렌더링 엔진은 script 태그를 만나면 DOM 생성을 중단하고 자바스크립트 엔진에 제어권을 넘김
- 자바스크립트 엔진은 JS 코드를 시스템이 이해할 수 있는 저수준 언어로 변환, 실행함
- 자바스크립트 엔진은 JS 코드를 파싱해서 AST(추상구문트리)를 생성함
- 토크나이징 = 소스코드를 최소 단위인 토큰으로 분해하는 과정
- 파싱 = 토큰들의 집합을 구문분석 하여 AST 생성
- 바이트코드 생성과 실행 = AST는 바이트코드로 변환되고 인터프리터에 의해 실행됨

## 38.7 리플로우와 리페인트

- DOM API에 의해 DOM이나 CSSOM이 변경되면 변경된 DOM과 CSSOM이 다시 렌더 트리로 결합되고 렌더링됨
- 이를 리플로우, 리페인트라고 부름
- 리플로우는 레이아웃 계산을 다시 하는 것
  - 노드 추가/삭제, 요소의 크기/위치 변경, 윈도우 리사이징 등 레이아웃에 영향을 주는 변경 발생시 실행됨
- 리페인트는 재결합된 렌더 트리를 기반으로 다시 페인트를 하는 것

## 38.8 자바스크립트 파싱에 의한 HTML 파싱 중단

- 렌더링 엔진과 JS 엔진은 직렬적으로 파싱을 수행함
- 그래서 script 태그의 위치가 중요함
- 보통은 DOM 생성이 끝난 후 조작을 가하는게 에러 위험이 적음

## 38.9 script 태그의 async/defer 어트리뷰트

- JS 파싱에 의해 DOM 생성이 블로킹 되는 문제를 해결하기 위해 HTML5부터 script 태그에 async/defer 어트리뷰트가 추가됨
- 근데 인라인 JS에는 사용할 수 없고 외부 JS 파일을 로드할때만 가능
- async 어트리뷰트
  - HTML 파싱과 JS 파일 로드가 비동기적으로 진행됨됨
  - 단, 로딩만 비동기적이고 JS 파싱과 실행 중에는 HTML 파싱이 중단됨
- defer 어트리뷰트
  - HTML 파싱과 JS 파일 로드가 비동기적으로 진행됨
  - JS 파싱과 실행은 HTML 파싱이 완료된 후(DOM 생성 후)에 진행됨
