# 14장 전역 변수의 문제점

## 14.1 변수의 생명 주기

### 14.1.1 지역 변수의 생명 주기

- 변수의 생성, 할당, 소멸을 생명 주기라 부름
- 생명 주기가 없다면 변수가 영원히 프로그램의 메모리 공간을 차지하게 됨
- 변수는 선언된 스코프에 따라 생성되고 소멸됨 (지역변수는 해당 스코프가 종료되면 같이 소멸함)

### 14.1.2 전역 변수의 생명 주기

- 전역 객체 : 브라우저에서는 window, 서버 환경에서는 global 객체를 의미

## 14.2 전역 변수의 문제점

- 암묵적 결합 : 모든 코드가 전역 변수를 참조하고 변경할 수 있다는 뜻
- 긴 생명 주기 : 메모리 리소스를 오랜 기간동안 소모하며, 상태 변경에 의한 오류 발생 가능성이 높음
- 스코프 체인 상에서 종점에 존재 : 전역 변수는 스코프 체인 상에서 종점에 위치하여 마지막에 검색됨 = 검색 속도가 느림
- 네임스페이스 오염 : JS는 파일이 분리되어있더라도 하나의 전역 스코프를 공유함. 서로 다른 파일 내에서 동일 이름을 사용한다면 오류 발생 가능성 높음

## 14.3 전역 변수의 사용을 억제하는 방법

### 14.3.1 즉시 실행 함수

- 함수 정의와 동시에 호출되는 함수
- 코드를 즉시 실행 함수로 감싸면 변수를 지역변수로 변경할 수 있음

### 14.3.2 네임스페이스 객체

- 전역 네임 스페이스 객체를 생성하고, 전역 변수로 사용하고 싶은 변수를 프로퍼티로 추가하여 사용
- 식별자 충돌을 방지할 수 있지만 전역 네임스페이스가 생기는 것이므로 또다른 문제 발생 가능

### 14.3.3 모듈 패턴

- 관련 변수와 함수를 모아 즉시 실행 함수로 감싸는 방법으로 하나의 모듈을 만듦
- 클로저를 기반으로 동작
- 전역 변수 억제 및 캡슐화 구현 가능
- 캡슐화 : 객체의 상태와 객체의 상태를 참조 / 조작할 수 있는 메서드를 하나로 묶는 것. 객체의 특정 프로퍼티나 메서드를 감추는데 사용하기도 함(정보 은닉)
- 클로저 : 함수 선언 시 그 함수가 선언된 스코프를 기억하여 외부 함수의 실행이 종료된 뒤에도 내부 함수(클로저)가 외부 함수의 변수에 계속 접근할 수 있음

```
  function counter() {
  let count = 0; // 외부 함수의 지역 변수

  return function() {
  count += 1;
  return count;
  };
  }

const increment = counter();
console.log(increment()); // 1
console.log(increment()); // 2
```

### 14.3.4 ES6 모듈

- ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공
- ES6 모듈 사용 시 더이상 전역 변수를 사용할 수 없음
